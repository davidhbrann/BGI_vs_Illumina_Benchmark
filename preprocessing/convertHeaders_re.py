#!/usr/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import argparse
import gzip
import re
import logging
import time

logging.basicConfig(
    stream=sys.stdout,
    format="%(asctime)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)

# Rewrite as illumina header
def convertIllumina(elements_dict):
    template_str = "@{instrument}:{run_number}:{flowcell_id}:{lane}:{tile}:{x_pos}:{y_pos} {read}:N:0:{sample_barcode}\n"
    formatted_string = template_str.format(
        instrument=elements_dict["instrument"],
        run_number=elements_dict["run_number"],
        flowcell_id=elements_dict["flowcell-id"],
        lane=elements_dict["lane"],
        tile=elements_dict["tile"],
        x_pos=elements_dict["x-pos"],
        y_pos=elements_dict["y-pos"],
        read=elements_dict["read_no"],
        sample_barcode=elements_dict["sample_barcode"],
    )
    return formatted_string


# Collect elements from BGI format
# Please note that you will need to attach the sample barcode sequence
# to the headers of the input FASTQ file
# eg.
def parseBGI(header, flowcell_id, barcode):
    # Extract sample barcode sequence
    splits = re.split(
        f"@{flowcell_id}L(\d)C(\d\d\d)R(\d\d\d)(\d+)/(\d)_{barcode}\n", header
    )
    splits = [int(x) if x.isdigit() else x for x in splits]
    _, lane_id, x_id, y_id, tile_number, paired_read_direction, _ = splits
    # Pack into dictionary
    elements_dict = {
        "instrument": "MGISEQ-2000",
        "run_number": 1,
        "sample_barcode": barcode,
        "lane": lane_id,
        "x-pos": x_id,
        "y-pos": y_id,
        "tile": tile_number,
        "flowcell-id": flowcell_id,
        "read_no": paired_read_direction,
    }
    return elements_dict


# Parses the entry
def parseLine(x, sample, barcode):
    if x.startswith(f"@{sample}"):
        elements_dict = parseBGI(x, sample, barcode)
        converted_header = convertIllumina(elements_dict)
        return converted_header
    else:
        return x


def open_file(input_file, mode="rb"):
    if ".gz" in input_file:
        input_fastq = gzip.open(input_file, mode)
    else:
        input_fastq = open(input_file, mode)
    return input_fastq


# Sets up arguments for user input
def setupParser():
    # Set up argument parser
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-i",
        "--input",
        action="store",
        help="fastq.gz file generated by BGI platform.",
        type=str,
        required=True,
    )
    parser.add_argument(
        "-o",
        "--output",
        action="store",
        help="Name of output converted file.",
        type=str,
        required=True,
    )
    parser.add_argument(
        "-s",
        "--sample",
        type=str,
        required=True,
    )
    parser.add_argument(
        "-b",
        "--barcode",
        type=str,
        required=True,
    )
    parser.add_argument("--verbose", dest="verbose", action="store_true")
    parser.set_defaults(verbose=False)
    args = parser.parse_args()
    return args


# Code starts here
if __name__ == "__main__":
    args = setupParser()
    input_file, output_file, sample, barcode = (
        args.input,
        args.output,
        args.sample,
        args.barcode,
    )
    input_fastq = open_file(input_file, "rt")
    output_fastq = open_file(output_file, "wt")

    start_time = time.time()
    for i, line in enumerate(input_fastq):
        if (args.verbose) and (i % 10_000_000 == 0):
            elapsed = time.time() - start_time
            logging.info(f"Read first {i // 40_00_000} million reads in {elapsed:.4f} seconds")
        parsed_line = parseLine(line, sample, barcode)
        output_fastq.write(parsed_line)

    input_fastq.close()
    output_fastq.close()
    elapsed = time.time() - start_time
    print(f"Conversion of {i // 4} reads in {input_file} complete in {elapsed:.4f} seconds!")